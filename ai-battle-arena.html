<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Battle Arena - Game Jam Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle, #2c1810, #0a0a0a);
            font-family: 'Courier New', monospace;
            color: #00ff00;
            overflow: hidden;
            cursor: crosshair;
        }
        
        #gameCanvas {
            display: block;
            border: 2px solid #00ff00;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            font-size: 20px;
            text-shadow: 0 0 10px #00ff00;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid #ff0000;
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border: 1px solid #00ff00;
            border-radius: 10px;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border: 2px solid #ff0000;
            border-radius: 15px;
            display: none;
        }
        
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #00cc00;
            box-shadow: 0 0 10px #00ff00;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="crosshair"></div>
    
    <div id="ui">
        <div>üéØ Score: <span id="score">0</span></div>
        <div>‚ù§Ô∏è Health: <span id="health">100</span></div>
        <div>üî´ Ammo: <span id="ammo">30</span></div>
        <div>ü§ñ Wave: <span id="wave">1</span></div>
        <div>üèÜ Kills: <span id="kills">0</span></div>
        <div>‚ö° Beam (Q): <span id="beam">Ready</span></div>
        <div>‚ùÑÔ∏è Freeze (E): <span id="freeze">Ready</span></div>
    </div>
    
    <div id="instructions">
        <h3>üéÆ AI BATTLE ARENA</h3>
        <p><strong>WASD</strong>: Move ‚Ä¢ <strong>Mouse</strong>: Aim ‚Ä¢ <strong>Click</strong>: Shoot ‚Ä¢ <strong>R</strong>: Reload ‚Ä¢ <strong>M</strong>: Toggle Sound</p>
        <p><strong>Q</strong>: Beam Attack (find üü† orange pickups) ‚Ä¢ <strong>E</strong>: Freeze Enemies (find üîµ cyan pickups)</p>
        <p>ü§ñ Smart AI enemies hunt you ‚Ä¢ üí• Shoot them before they get you!</p>
        <p>üéÅ Collect: üü° Ammo, üü¢ Health, üü† Beam, üîµ Freeze ‚Ä¢ üìà Survive endless waves!</p>
    </div>
    
    <div id="gameOver">
        <h2>üíÄ GAME OVER üíÄ</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Waves Survived: <span id="finalWave">0</span></p>
        <p>Total Kills: <span id="finalKills">0</span></p>
        <button onclick="restartGame()">üîÑ PLAY AGAIN</button>
    </div>

    <script>
        // Sound system using Web Audio API
        let audioContext;
        let soundEnabled = true;
        
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Web Audio API not supported');
                soundEnabled = false;
            }
        }
        
        function playSound(frequency, duration, type = 'sine', volume = 0.1, fadeOut = true) {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.value = volume;
            
            if (fadeOut) {
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            }
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playShootSound() {
            if (!soundEnabled) return;
            // Sharp shooting sound
            playSound(800, 0.1, 'square', 0.05);
            setTimeout(() => playSound(400, 0.05, 'sawtooth', 0.03), 50);
        }
        
        function playHitSound() {
            if (!soundEnabled) return;
            // Impact sound
            playSound(200, 0.2, 'sawtooth', 0.08);
        }
        
        function playEnemyDeathSound() {
            if (!soundEnabled) return;
            // Explosion sound
            playSound(150, 0.3, 'sawtooth', 0.1);
            setTimeout(() => playSound(100, 0.2, 'square', 0.08), 100);
        }
        
        function playPickupSound() {
            if (!soundEnabled) return;
            // Pleasant pickup sound
            playSound(600, 0.2, 'sine', 0.06);
            setTimeout(() => playSound(800, 0.2, 'sine', 0.04), 100);
        }
        
        function playDamageSound() {
            if (!soundEnabled) return;
            // Player damage sound
            playSound(120, 0.4, 'sawtooth', 0.12);
        }
        
        function playReloadSound() {
            if (!soundEnabled) return;
            // Reload click sound
            playSound(300, 0.1, 'square', 0.04);
            setTimeout(() => playSound(250, 0.1, 'square', 0.03), 200);
        }
        
        function playWaveCompleteSound() {
            if (!soundEnabled) return;
            // Victory fanfare
            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            notes.forEach((note, i) => {
                setTimeout(() => playSound(note, 0.3, 'sine', 0.08), i * 150);
            });
        }
        
        function playGameOverSound() {
            if (!soundEnabled) return;
            // Descending death sound
            playSound(400, 0.5, 'sawtooth', 0.15);
            setTimeout(() => playSound(300, 0.5, 'sawtooth', 0.12), 200);
            setTimeout(() => playSound(200, 0.8, 'sawtooth', 0.1), 400);
        }
        
        function playAmbientDrone() {
            if (!soundEnabled) return;
            // Low ambient drone for atmosphere
            playSound(60, 2, 'sine', 0.02, false);
            setTimeout(() => playAmbientDrone(), 1800);
        }
        
        function playBeamSound() {
            if (!soundEnabled) return;
            // Powerful beam sound
            playSound(150, 2, 'sawtooth', 0.15);
            setTimeout(() => playSound(200, 1.8, 'square', 0.1), 100);
            setTimeout(() => playSound(300, 1.6, 'sine', 0.08), 200);
        }
        
        function playFreezeSound() {
            if (!soundEnabled) return;
            // Ice freeze sound
            playSound(400, 0.3, 'sine', 0.1);
            setTimeout(() => playSound(300, 0.4, 'sine', 0.08), 200);
            setTimeout(() => playSound(200, 0.5, 'triangle', 0.06), 400);
        }
        
        function playAbilityCooldownSound() {
            if (!soundEnabled) return;
            // Ability ready sound
            playSound(600, 0.2, 'sine', 0.05);
            setTimeout(() => playSound(800, 0.1, 'sine', 0.03), 150);
        }
        
        // Game state
        let canvas, ctx;
        let gameState = {
            player: { x: 400, y: 300, health: 100, angle: 0 },
            enemies: [],
            bullets: [],
            pickups: [],
            particles: [],
            score: 0,
            wave: 1,
            kills: 0,
            ammo: 30,
            maxAmmo: 30,
            reloading: false,
            keys: {},
            mouse: { x: 0, y: 0, down: false },
            gameRunning: true,
            lastShot: 0,
            waveTimer: 0,
            waveTransition: false,
            lastSurvivalPoint: Date.now(),
            // Special abilities - must be collected
            abilities: {
                beam: { charges: 0, duration: 0, active: false },
                freeze: { charges: 0, duration: 0, active: false }
            },
            beamEffect: null,
            frozenEnemies: new Set()
        };
        
        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth - 4;
            canvas.height = window.innerHeight - 4;
            
            initAudio();
            setupControls();
            spawnWave();
            gameLoop();
            
            // Start ambient sound after user interaction
            setTimeout(() => playAmbientDrone(), 2000);
        }
        
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.code] = true;
                if (e.code === 'KeyR') reload();
                if (e.code === 'KeyM') {
                    soundEnabled = !soundEnabled;
                    console.log('Sound', soundEnabled ? 'enabled' : 'disabled');
                }
                if (e.code === 'KeyQ') activateBeam();
                if (e.code === 'KeyE') activateFreeze();
                
                // Resume audio context on first user interaction
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.code] = false;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                gameState.mouse.x = e.clientX - rect.left;
                gameState.mouse.y = e.clientY - rect.top;
            });
            
            canvas.addEventListener('mousedown', () => {
                gameState.mouse.down = true;
                
                // Resume audio context on first click
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                shoot();
            });
            
            canvas.addEventListener('mouseup', () => {
                gameState.mouse.down = false;
            });
        }
        
        function spawnWave() {
            // Much slower wave scaling - more reasonable progression
            const enemyCount = Math.min(2 + Math.floor(gameState.wave * 1.5), 15); // Cap at 15 enemies max
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => spawnEnemy(), i * 2000); // 2 second delay between spawns
            }
            
            // Spawn pickups
            if (Math.random() < 0.7) {
                spawnPickup();
            }
        }
        
        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(side) {
                case 0: x = Math.random() * canvas.width; y = -50; break;
                case 1: x = canvas.width + 50; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 50; break;
                case 3: x = -50; y = Math.random() * canvas.height; break;
            }
            
            gameState.enemies.push({
                x, y,
                health: 20 + gameState.wave * 5,
                maxHealth: 20 + gameState.wave * 5,
                speed: 1 + gameState.wave * 0.3,
                type: Math.random() < 0.3 ? 'fast' : 'normal',
                lastAttack: 0,
                angle: 0,
                ai: {
                    state: 'hunt',
                    lastDecision: 0,
                    targetX: gameState.player.x,
                    targetY: gameState.player.y
                }
            });
        }
        
        function spawnPickup() {
            const rand = Math.random();
            let type;
            if (rand < 0.4) {
                type = 'ammo';
            } else if (rand < 0.7) {
                type = 'health';
            } else if (rand < 0.85) {
                type = 'beam';
            } else {
                type = 'freeze';
            }
            
            gameState.pickups.push({
                x: 100 + Math.random() * (canvas.width - 200),
                y: 100 + Math.random() * (canvas.height - 200),
                type,
                rotation: 0,
                pulse: 0
            });
        }
        
        function shoot() {
            if (!gameState.gameRunning || gameState.reloading) return;
            if (gameState.ammo <= 0) {
                reload();
                return;
            }
            if (Date.now() - gameState.lastShot < 150) return;
            
            const dx = gameState.mouse.x - gameState.player.x;
            const dy = gameState.mouse.y - gameState.player.y;
            const angle = Math.atan2(dy, dx);
            
            gameState.bullets.push({
                x: gameState.player.x,
                y: gameState.player.y,
                dx: Math.cos(angle) * 8,
                dy: Math.sin(angle) * 8,
                life: 100
            });
            
            gameState.ammo--;
            gameState.lastShot = Date.now();
            
            // Play shooting sound
            playShootSound();
            
            // Muzzle flash
            for (let i = 0; i < 5; i++) {
                gameState.particles.push({
                    x: gameState.player.x,
                    y: gameState.player.y,
                    dx: (Math.random() - 0.5) * 4,
                    dy: (Math.random() - 0.5) * 4,
                    life: 10,
                    color: '#ffff00'
                });
            }
        }
        
        function reload() {
            if (gameState.reloading || gameState.ammo === gameState.maxAmmo) return;
            gameState.reloading = true;
            
            // Play reload sound
            playReloadSound();
            
            setTimeout(() => {
                gameState.ammo = gameState.maxAmmo;
                gameState.reloading = false;
            }, 1500);
        }
        
        function activateBeam() {
            if (gameState.abilities.beam.charges <= 0 || !gameState.gameRunning) return;
            
            gameState.abilities.beam.active = true;
            gameState.abilities.beam.duration = 2000; // 2 seconds
            gameState.abilities.beam.charges--;
            
            // Play beam sound
            playBeamSound();
            
            // Create beam effect
            gameState.beamEffect = {
                startX: gameState.player.x,
                startY: gameState.player.y,
                angle: gameState.player.angle,
                width: 40,
                length: Math.max(canvas.width, canvas.height)
            };
            
            // Damage all enemies in beam path
            damageEnemiesInBeam();
        }
        
        function activateFreeze() {
            if (gameState.abilities.freeze.charges <= 0 || !gameState.gameRunning) return;
            
            gameState.abilities.freeze.active = true;
            gameState.abilities.freeze.duration = 4000; // 4 seconds
            gameState.abilities.freeze.charges--;
            
            // Play freeze sound
            playFreezeSound();
            
            // Freeze all enemies
            gameState.enemies.forEach((enemy, index) => {
                gameState.frozenEnemies.add(index);
            });
            
            // Add freeze particles
            for (let i = 0; i < 50; i++) {
                gameState.particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    dx: (Math.random() - 0.5) * 2,
                    dy: (Math.random() - 0.5) * 2,
                    life: 60,
                    color: '#00ffff'
                });
            }
        }
        
        function damageEnemiesInBeam() {
            const beam = gameState.beamEffect;
            if (!beam) return;
            
            gameState.enemies.forEach((enemy, index) => {
                // Calculate if enemy is in beam path
                const dx = enemy.x - beam.startX;
                const dy = enemy.y - beam.startY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance > beam.length) return;
                
                // Check angle alignment
                const enemyAngle = Math.atan2(dy, dx);
                const angleDiff = Math.abs(enemyAngle - beam.angle);
                const normalizedDiff = Math.min(angleDiff, Math.PI*2 - angleDiff);
                
                if (normalizedDiff <= beam.width / 200) { // Hit detection
                    enemy.health -= 100; // Massive beam damage
                    
                    // Beam hit particles
                    for (let i = 0; i < 8; i++) {
                        gameState.particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            dx: (Math.random() - 0.5) * 6,
                            dy: (Math.random() - 0.5) * 6,
                            life: 25,
                            color: '#ffff00'
                        });
                    }
                    
                    if (enemy.health <= 0) {
                        gameState.score += 50; // Bonus for beam kill
                        gameState.kills++;
                        gameState.enemies.splice(index, 1);
                        playEnemyDeathSound();
                        
                        // Death explosion
                        for (let i = 0; i < 15; i++) {
                            gameState.particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                dx: (Math.random() - 0.5) * 10,
                                dy: (Math.random() - 0.5) * 10,
                                life: 40,
                                color: '#ff4400'
                            });
                        }
                    }
                }
            });
        }
        
        function updatePlayer() {
            const speed = 4;
            
            if (gameState.keys['KeyW']) gameState.player.y -= speed;
            if (gameState.keys['KeyS']) gameState.player.y += speed;
            if (gameState.keys['KeyA']) gameState.player.x -= speed;
            if (gameState.keys['KeyD']) gameState.player.x += speed;
            
            // Keep in bounds
            gameState.player.x = Math.max(20, Math.min(canvas.width - 20, gameState.player.x));
            gameState.player.y = Math.max(20, Math.min(canvas.height - 20, gameState.player.y));
            
            // Player angle
            const dx = gameState.mouse.x - gameState.player.x;
            const dy = gameState.mouse.y - gameState.player.y;
            gameState.player.angle = Math.atan2(dy, dx);
        }
        
        function updateEnemies() {
            gameState.enemies.forEach((enemy, i) => {
                // Check if enemy is frozen
                if (gameState.frozenEnemies.has(i)) {
                    // Frozen enemies don't move or attack
                    return;
                }
                
                // Smart AI behavior
                const now = Date.now();
                if (now - enemy.ai.lastDecision > 500) {
                    const distToPlayer = Math.sqrt(
                        (gameState.player.x - enemy.x) ** 2 + 
                        (gameState.player.y - enemy.y) ** 2
                    );
                    
                    if (distToPlayer < 100) {
                        enemy.ai.state = 'attack';
                    } else if (distToPlayer > 300) {
                        enemy.ai.state = 'hunt';
                        enemy.ai.targetX = gameState.player.x;
                        enemy.ai.targetY = gameState.player.y;
                    } else {
                        enemy.ai.state = Math.random() < 0.7 ? 'hunt' : 'flank';
                        if (enemy.ai.state === 'flank') {
                            enemy.ai.targetX = gameState.player.x + (Math.random() - 0.5) * 200;
                            enemy.ai.targetY = gameState.player.y + (Math.random() - 0.5) * 200;
                        }
                    }
                    enemy.ai.lastDecision = now;
                }
                
                // Move based on AI state
                let targetX, targetY;
                if (enemy.ai.state === 'attack') {
                    targetX = gameState.player.x;
                    targetY = gameState.player.y;
                } else {
                    targetX = enemy.ai.targetX;
                    targetY = enemy.ai.targetY;
                }
                
                const dx = targetX - enemy.x;
                const dy = targetY - enemy.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 5) {
                    let speed = enemy.speed;
                    if (enemy.type === 'fast') speed *= 1.5;
                    
                    enemy.x += (dx / dist) * speed;
                    enemy.y += (dy / dist) * speed;
                }
                
                enemy.angle = Math.atan2(gameState.player.y - enemy.y, gameState.player.x - enemy.x);
                
                // Attack player
                const playerDist = Math.sqrt(
                    (gameState.player.x - enemy.x) ** 2 + 
                    (gameState.player.y - enemy.y) ** 2
                );
                
                if (playerDist < 40 && now - enemy.lastAttack > 1000) {
                    gameState.player.health -= enemy.type === 'fast' ? 15 : 10;
                    enemy.lastAttack = now;
                    
                    // Play damage sound
                    playDamageSound();
                    
                    // Damage particles
                    for (let j = 0; j < 8; j++) {
                        gameState.particles.push({
                            x: gameState.player.x,
                            y: gameState.player.y,
                            dx: (Math.random() - 0.5) * 6,
                            dy: (Math.random() - 0.5) * 6,
                            life: 20,
                            color: '#ff0000'
                        });
                    }
                    
                    if (gameState.player.health <= 0) {
                        endGame();
                    }
                }
            });
        }
        
        function updateBullets() {
            gameState.bullets.forEach((bullet, i) => {
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                bullet.life--;
                
                if (bullet.life <= 0 || 
                    bullet.x < 0 || bullet.x > canvas.width || 
                    bullet.y < 0 || bullet.y > canvas.height) {
                    gameState.bullets.splice(i, 1);
                    return;
                }
                
                // Check enemy hits
                gameState.enemies.forEach((enemy, j) => {
                    const dist = Math.sqrt((bullet.x - enemy.x) ** 2 + (bullet.y - enemy.y) ** 2);
                    if (dist < 25) {
                        enemy.health -= 25;
                        gameState.bullets.splice(i, 1);
                        
                        // Play hit sound
                        playHitSound();
                        
                        // Hit particles
                        for (let k = 0; k < 6; k++) {
                            gameState.particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                dx: (Math.random() - 0.5) * 4,
                                dy: (Math.random() - 0.5) * 4,
                                life: 15,
                                color: '#ff8800'
                            });
                        }
                        
                        if (enemy.health <= 0) {
                            gameState.score += 25; // Reduced kill points
                            gameState.kills++;
                            gameState.enemies.splice(j, 1);
                            
                            // Play death sound
                            playEnemyDeathSound();
                            
                            // Death explosion
                            for (let k = 0; k < 12; k++) {
                                gameState.particles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    dx: (Math.random() - 0.5) * 8,
                                    dy: (Math.random() - 0.5) * 8,
                                    life: 30,
                                    color: '#ff0000'
                                });
                            }
                        }
                    }
                });
            });
        }
        
        function updatePickups() {
            gameState.pickups.forEach((pickup, i) => {
                pickup.rotation += 0.1;
                pickup.pulse += 0.2;
                
                const dist = Math.sqrt(
                    (gameState.player.x - pickup.x) ** 2 + 
                    (gameState.player.y - pickup.y) ** 2
                );
                
                if (dist < 30) {
                    if (pickup.type === 'ammo') {
                        gameState.maxAmmo += 10;
                        gameState.ammo = gameState.maxAmmo;
                    } else if (pickup.type === 'health') {
                        gameState.player.health = Math.min(100, gameState.player.health + 30);
                    } else if (pickup.type === 'beam') {
                        gameState.abilities.beam.charges++;
                        gameState.score += 25; // Bonus for ability pickup
                    } else if (pickup.type === 'freeze') {
                        gameState.abilities.freeze.charges++;
                        gameState.score += 25; // Bonus for ability pickup
                    }
                    
                    // Play pickup sound
                    playPickupSound();
                    
                    gameState.pickups.splice(i, 1);
                    gameState.score += 10; // Base pickup points
                }
            });
        }
        
        function updateParticles() {
            gameState.particles.forEach((particle, i) => {
                particle.x += particle.dx;
                particle.y += particle.dy;
                particle.life--;
                particle.dx *= 0.95;
                particle.dy *= 0.95;
                
                if (particle.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            });
        }
        
        function checkWaveComplete() {
            if (gameState.enemies.length === 0 && !gameState.waveTransition) {
                gameState.waveTransition = true;
                gameState.wave++;
                gameState.score += gameState.wave * 50; // Reduced wave bonus
                
                // Play wave complete sound
                playWaveCompleteSound();
                
                // Show wave complete message
                setTimeout(() => {
                    gameState.waveTransition = false;
                    spawnWave();
                }, 3000); // Longer pause between waves
            }
        }
        
        function render() {
            // Clear screen
            ctx.fillStyle = '#001100';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid pattern
            ctx.strokeStyle = '#002200';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            
            // Draw particles
            gameState.particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / 30;
                ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
                ctx.globalAlpha = 1;
            });
            
            // Draw pickups
            gameState.pickups.forEach(pickup => {
                ctx.save();
                ctx.translate(pickup.x, pickup.y);
                ctx.rotate(pickup.rotation);
                
                const size = 15 + Math.sin(pickup.pulse) * 3;
                
                // Different colors for different pickup types
                if (pickup.type === 'ammo') {
                    ctx.fillStyle = '#ffff00'; // Yellow
                } else if (pickup.type === 'health') {
                    ctx.fillStyle = '#00ff00'; // Green
                } else if (pickup.type === 'beam') {
                    ctx.fillStyle = '#ff8800'; // Orange
                } else if (pickup.type === 'freeze') {
                    ctx.fillStyle = '#00ffff'; // Cyan
                }
                
                ctx.fillRect(-size/2, -size/2, size, size);
                
                // Special outline for abilities
                if (pickup.type === 'beam' || pickup.type === 'freeze') {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(-size/2, -size/2, size, size);
                    
                    // Glowing effect for abilities
                    ctx.shadowColor = pickup.type === 'beam' ? '#ff8800' : '#00ffff';
                    ctx.shadowBlur = 10;
                    ctx.strokeRect(-size/2, -size/2, size, size);
                    ctx.shadowBlur = 0;
                } else {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-size/2, -size/2, size, size);
                }
                
                ctx.restore();
            });
            
            // Draw player
            ctx.save();
            ctx.translate(gameState.player.x, gameState.player.y);
            ctx.rotate(gameState.player.angle);
            
            // Player body
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(-15, -10, 30, 20);
            
            // Player gun
            ctx.fillStyle = '#888888';
            ctx.fillRect(15, -2, 20, 4);
            
            ctx.restore();
            
            // Draw beam effect
            if (gameState.beamEffect && gameState.abilities.beam.active) {
                const beam = gameState.beamEffect;
                ctx.save();
                ctx.translate(beam.startX, beam.startY);
                ctx.rotate(beam.angle);
                
                // Beam core
                const gradient = ctx.createLinearGradient(0, -beam.width/2, 0, beam.width/2);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, -beam.width/2, beam.length, beam.width);
                
                // Beam outline
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.strokeRect(0, -beam.width/2, beam.length, beam.width);
                
                ctx.restore();
            }
            
            // Draw enemies
            gameState.enemies.forEach((enemy, index) => {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                ctx.rotate(enemy.angle);
                
                // Enemy body - change color if frozen
                if (gameState.frozenEnemies.has(index)) {
                    ctx.fillStyle = '#4444ff'; // Frozen blue
                } else {
                    ctx.fillStyle = enemy.type === 'fast' ? '#ff6600' : '#ff0000';
                }
                ctx.fillRect(-20, -15, 40, 30);
                
                // Frozen effect
                if (gameState.frozenEnemies.has(index)) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-20, -15, 40, 30);
                }
                
                // Health bar
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-20, -25, 40, 5);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(-20, -25, (enemy.health / enemy.maxHealth) * 40, 5);
                
                ctx.restore();
            });
            
            // Draw bullets
            gameState.bullets.forEach(bullet => {
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(bullet.x - 2, bullet.y - 2, 4, 4);
            });
        }
        
        function updateAbilities() {
            // Update beam ability duration
            if (gameState.abilities.beam.active) {
                gameState.abilities.beam.duration -= 16; // ~60fps
                if (gameState.abilities.beam.duration <= 0) {
                    gameState.abilities.beam.active = false;
                    gameState.beamEffect = null;
                }
            }
            
            // Update freeze ability duration
            if (gameState.abilities.freeze.active) {
                gameState.abilities.freeze.duration -= 16;
                if (gameState.abilities.freeze.duration <= 0) {
                    gameState.abilities.freeze.active = false;
                    gameState.frozenEnemies.clear();
                }
            }
        }
        
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('health').textContent = Math.max(0, gameState.player.health);
            document.getElementById('ammo').textContent = gameState.reloading ? 'RELOADING...' : gameState.ammo;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('kills').textContent = gameState.kills;
            
            // Update ability display
            document.getElementById('beam').textContent = 
                gameState.abilities.beam.active ? 'ACTIVE!' : 
                gameState.abilities.beam.charges > 0 ? `x${gameState.abilities.beam.charges}` : 'Need Pickup';
                
            document.getElementById('freeze').textContent = 
                gameState.abilities.freeze.active ? 'ACTIVE!' : 
                gameState.abilities.freeze.charges > 0 ? `x${gameState.abilities.freeze.charges}` : 'Need Pickup';
            
            // Add survival points much slower - only every 60 frames (1 second)
            if (Date.now() - gameState.lastSurvivalPoint > 1000) {
                gameState.score += Math.max(1, Math.floor(gameState.wave / 5)); // Scale with wave
                gameState.lastSurvivalPoint = Date.now();
            }
        }
        
        function endGame() {
            gameState.gameRunning = false;
            
            // Play game over sound
            playGameOverSound();
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalWave').textContent = gameState.wave;
            document.getElementById('finalKills').textContent = gameState.kills;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restartGame() {
            gameState = {
                player: { x: 400, y: 300, health: 100, angle: 0 },
                enemies: [],
                bullets: [],
                pickups: [],
                particles: [],
                score: 0,
                wave: 1,
                kills: 0,
                ammo: 30,
                maxAmmo: 30,
                reloading: false,
                keys: {},
                mouse: { x: 0, y: 0, down: false },
                gameRunning: true,
                lastShot: 0,
                waveTimer: 0,
                waveTransition: false,
                lastSurvivalPoint: Date.now(),
                // Special abilities - must be collected
                abilities: {
                    beam: { charges: 0, duration: 0, active: false },
                    freeze: { charges: 0, duration: 0, active: false }
                },
                beamEffect: null,
                frozenEnemies: new Set()
            };
            
            document.getElementById('gameOver').style.display = 'none';
            spawnWave();
        }
        
        function gameLoop() {
            if (gameState.gameRunning) {
                updatePlayer();
                updateEnemies();
                updateBullets();
                updatePickups();
                updateParticles();
                updateAbilities();
                checkWaveComplete();
                updateUI();
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game
        window.addEventListener('load', init);
    </script>
</body>
</html>